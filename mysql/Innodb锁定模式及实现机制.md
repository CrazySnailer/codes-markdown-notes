###Innodb锁定模式及实现机制

考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而Innodb 是目前事务型存
储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下Innodb 的锁定特性。
总的来说，Innodb 的锁定机制和Oracle 数据库有不少相似之处。Innodb 的行级锁定同样分为两种类
型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存， Innodb 也同样使用
了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。

当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源
的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一
个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向
锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时
候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上
面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表
上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所
以，可以说Innodb 的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和
意向排他锁（IX）。

虽然Innodb 的锁定机制和Oracle 有不少相近的地方，但是两者的实现确是截然不同的。总的来说就
是Oracle 锁定数据是通过需要锁定的某行记录所在的物理block 上的事务槽上表级锁定信息，而Innodb
的锁定则是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记锁定信息
而实现的。Innodb 的这种锁定实现方式被称为“NEXT-KEY locking”（间隙锁），因为Query 执行过程
中通过过范围查找的华，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。

间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜
的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成
很大的危害。而Innodb 给出的解释是为了组织幻读的出现，所以他们选择的间隙锁来实现锁定。

除了间隙锁给Innodb 带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：
* 当Query 无法利用索引的时候，Innodb 会放弃使用行级别锁定而改用表级别的锁定，造成并发
性能的降低；
* 当Quuery 使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可
能有部分并不属于该Query 的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范
围，而不是具体的索引键；
* 当Query 在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索
引只是过滤条件的一部分），一样会被锁定；

Innodb 各事务隔离级别下锁定及死锁
Innodb 实现的在ISO／ANSI SQL92 规范中所定义的Read UnCommited，Read Commited，Repeatable
Read 和Serializable 这四种事务隔离级别。同时，为了保证数据在事务中的一致性，实现了多版本数据
访问。

行级锁定肯定会带来死锁问题，Innodb 也不可能例外。

在Innodb 的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间
内就检测到该死锁的存在。当Innodb 检测到系统中产生了死锁之后，Innodb 会通过相应的判断来选这产
生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。那Innodb 是以什么来为标
准判定事务的大小的呢？MySQL 官方手册中也提到了这个问题，实际上在Innodb 发现死锁之后，会计算
出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录
条数越多，在死锁中就越不会被回滚掉。但是有一点需要注意的就是，当产生死锁的场景中涉及到不止
Innodb 存储引擎的时候，Innodb 是没办法检测到该死锁的，这时候就只能通过锁定超时限制来解决该死
锁了。

要想合理利用Innodb 的行级锁定，做到扬长避短，我们必须做好以下工作：
* 尽可能让所有的数据检索都通过索引来完成，从而避免Innodb 因为无法通过索引键加锁而升级
为表级锁定；
* 合理设计索引，让Innodb 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免
造成不必要的锁定而影响其他Query 的执行；
* 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定
的记录；
* 尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
* 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL 因为实现事务隔离级
别所带来的附加成本；

由于Innodb 的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率
的的小建议，读者朋友可以根据各自的业务特点针对性的尝试：
* 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
* 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁
产生的概率；

###行级锁定查询
	show status like 'innodb_row_lock%';
