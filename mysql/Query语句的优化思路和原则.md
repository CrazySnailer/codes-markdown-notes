###优化更需要优化的Query
假设有一个Query 每小时执行10000 次，每次需要20 个IO。另外一个Query 每小时执行10 次，
每次需要20000 个IO。
我们先通过IO 消耗方面来分析。可以看出，两个Query 每小时所消耗的IO 总数目是一样的，都是
200000 IO/小时。假设我们优化第一个Query，从20 个IO 降低到18 个IO，也就是仅仅降低了2 个IO，
则我们节省了2 * 10000 = 20000 （IO/小时）。而如果希望通过优化第二个Query 达到相同的效果，
我们必须要让每个Query 减少20000 / 10 = 2000 IO。我想大家都会相信让第一个Query 节省2 个IO
远比第二个Query 节省2000 个IO 来的容易。

###定位优化对象的性能瓶颈
当我们拿到一条需要优化的Query 之后，第一件事情是什么？是反问自己，这条Query 有什么问
题？我为什么要优化他？只有明白了这些问题，我们才知道我们需要做什么，才能够找到问题的关键。
而不能就只是觉得某个Query 好像有点慢，需要优化一下，然后就开始一个一个优化方法去轮番尝试。
这样很可能整个优化过程会消耗大量的人力和时间成本，甚至可能到最后还是得不到一个好的优化结
果。这就像看病一样，医生必须要清楚的知道我们病的根源才能对症下药。如果只是知道我们什么地方
不舒服，然后就开始通过各种药物尝试治疗，那这样所带来的后果可能就非常严重了。
所以，在拿到一条需要优化的Query 之后，我们首先要判断出这个Query 的瓶颈到底是IO 还是
CPU。到底是因为在数据访问消耗了太多的时间，还是在数据的运算（如分组排序等）方面花费了太多资
源？

###明确的优化目标
当我们定为到了一条Query 的性能瓶颈之后，就需要通过分析该Query 所完成的功能和Query 对
系统的整体影响制订出一个明确的优化目标。没有一个明确的目标，优化过程将是一个漫无目的而且低
效的过程，也很难达收到一个理想的效果。尤其是对于一些实现应用中较为重要功能点的Query 更是如
此。
如何设定优化目标？这可能是很多人都非常头疼的问题，对于我自己也一样。要设定一个合理的优
化目标，不能过于理想也不能放任自由，确实是一件非常头疼的事情。一般来说，我们首先需要清楚的
了解数据库目前的整体状态，同时也要清楚的知道数据库中与该Query 相关的数据库对象的各种信息，
而且还要了解该Query 在整个应用系统中所实现的功能。了解了数据库整体状态，我们就能知道数据库
所能承受的最大压力，也就清楚了我们能够接受的最悲观情况。把握了该Query 相关数据库对象的信
息，我们就应该知道实现该Query 的消耗最理想情况下需要消耗多少资源，最糟糕又需要消耗多少资
源。最后，通过该Query 所实现的功能点在整个应用系统中的重要地位，我们可以大概的分析出该
Query 可以占用的系统资源比例，而且我们也能够知道该Query 的效率给客户带来的体验影响到底有多
大。

###从Explain 入手
Explain 只是用来获取一个Query 在当前状态的数据库中的执行计
划，在优化动手之前，我们比需要根据优化目标在自己头脑中有一个清晰的目标执行计划。只有这样，
优化的目标才有意义。一个优秀的SQL 调优人员（或者成为SQL Performance Tuner），在优化任何一
个SQL 语句之前，都应该在自己头脑中已经先有一个预定的执行计划，然后通过不断的调整尝试，再借
助Explain 来验证调整的结果是否满足自己预定的执行计划。对于不符合预期的执行计划需要不断分析
Query 的写法和数据库对象的信息，继续调整尝试，直至得到预期的结果。
当然，人无完人，并不一定每次自己预设的执行计划都肯定是最优的，在不断调整测试的过程中，
如果发现MySQL Optimizer 所选择的执行计划的实际执行效果确实比自己预设的要好，我们当然还是应
该选择使用MySQL optimizer 所生成的执行计划。

###多使用profile

###永远用小结果集驱动大的结果集
在MySQL 中的Join，只有Nested Loop 一种Join 方式，也就是
MySQL 的Join 都是通过嵌套循环来实现的。驱动结果集越大，所需要循环的此时就越多，那么被驱动表
的访问次数自然也就越多，而每次访问被驱动表，即使需要的逻辑IO 很少，循环次数多了，总量自然也
不可能很小，而且每次循环都不能避免的需要消耗CPU ，所以CPU 运算量也会跟着增加。所以，如果
我们仅仅以表的大小来作为驱动表的判断依据，假若小表过滤后所剩下的结果集比大表多很多，结果就
是需要的嵌套循环中带来更多的循环次数，反之，所需要的循环次数就会更少，总体IO 量和CPU 运算
量也会少。而且，就算是非Nested Loop 的Join 算法，如Oracle 中的Hash Join，同样是小结果集
驱动大的结果集是最优的选择。

###尽可能在索引中完成排序

###只取出自己需要的Columns
对于任何Query，返回的数据都是需要通过网络数据包传回给客户端，如果取出的Column 越多，
需要传输的数据量自然会越大，不论是从网络带宽方面考虑还是从网络传输的缓冲区来看，都是一个浪
费。
如果是需要排序的Query 来说，影响就更大了。在MySQL 中存在两种排序算法，一种是在
MySQL4.1 之前的老算法，实现方式是先将需要排序的字段和可以直接定位到相关行数据的指针信息取
出，然后在我们所设定的排序区（通过参数sort_buffer_size 设定）中进行排序，完成排序之后再次
通过行指针信息取出所需要的Columns，也就是说这种算法需要访问两次数据。第二种排序算法是从
MySQL4.1 版本开始使用的改进算法，一次性将所需要的Columns 全部取出，在排序区中进行排序后直
接将数据返回给请求客户端。改行算法只需要访问一次数据，减少了大量的随机IO，极大的提高了带有
排序的Query 语句的效率。但是，这种改进后的排序算法需要一次性取出并缓存的数据比第一种算法
要多很多，如果我们将并不需要的Columns 也取出来，就会极大的浪费排序过程所需要的内存。在
MySQL4.1 之后的版本中，我们可以通过设置max_length_for_sort_data 参数大小来控制MySQL 选择
第一种排序算法还是第二种排序算法。当所取出的Columns 的单条记录总大小
max_length_for_sort_data 设置的大小的时候，MySQL 就会选择使用第一种排序算法，反之，则会选
择第二种优化后的算法。为了尽可能提高排序性能，我们自然是更希望使用第二种排序算法，所以在
Query 中仅仅取出我们所需要的Columns 是非常有必要的。

###仅仅使用最有效的过滤条件
需求： 查找某个用户在所有group 中所发的讨论message 基本信息。
场景： 
1. 知道用户ID 和用户nick_name
2. 信息所在表为group_message
3. group_message 中存在用户ID(user_id)和nick_name(author)两个索引

####方案1 将用户ID 和用户nick_name 两者都作为过滤条件放在WHERE 子句中来查询
```
EXPLAIN SELECT * FROM group_message WHERE user_id = 1 AND author='1111111111'\G
id: 1
select_type: SIMPLE
table: group_message
type: ref
possible_keys: group_message_author_ind,group_message_uid_ind
key: group_message_author_ind
key_len: 98
ref: const
rows: 1
Extra: Using where
1 row in set (0.00 sec)
```
####方案2 仅仅将用户ID 作为过滤条件放在WHERE 子句中来查询
```
EXPLAIN SELECT * FROM group_message WHERE user_id = 1\G
id: 1
select_type: SIMPLE
table: group_message
type: ref
possible_keys: group_message_uid_ind
key: group_message_uid_ind
key_len: 4
ref: const
rows: 1
Extra:
1 row in set (0.00 sec)
```
####方案3 仅将用户nick_name 作为过滤条件放在WHERE 子句中来查询
```
EXPLAIN SELECT * FROM group_message WHERE author = '1111111111'\G
id: 1
select_type: SIMPLE
table: group_message
type: ref
possible_keys: group_message_author_ind
key: group_message_author_ind
key_len: 98
ref: const
rows: 1
Extra: Using where
1 row in set (0.00 sec)
```

###尽可能避免复杂的Join 和子查询
MySQL 在并发这一块做的并不是太好，当并发量太高的时候，系统整体性能可能会急
剧下降，尤其是遇到一些较为复杂的Query 的时候更是如此。这主要与MySQL 内部资源的争用锁定控
制有关，如读写相斥等等。对于Innodb 存储引擎由于实现了行级锁定可能还要稍微好一些，如果使用
的MyISAM 存储引擎，并发一旦较高的时候，性能下降非常明显。所以，我们的Query 语句所涉及到的
表越多，所需要锁定的资源就越多。也就是说，越复杂的Join 语句，所需要锁定的资源也就越多，所
阻塞的其他线程也就越多。相反，如果我们将比较复杂的Query 语句分拆成多个较为简单的Query 语
句分步执行，每次锁定的资源也就会少很多，所阻塞的其他线程也要少一些。
