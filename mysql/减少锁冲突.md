###MyISAM 类型的表
1. Myisam 类型的表可以考虑通过改成Innodb 类型的表来减少锁冲突。
2. 根据应用的情况，尝试横向拆分成多个表或者改成MyISAM 分区对减少锁冲突也会有一定的帮助。

###Innodb 类型的表
1. 首先要确认，在对表获取行锁的时候，要尽量的使用索引检索纪录，如果没有使用索引访问，那么即便你只是要更新其中的一行纪录，也是全表锁定的。要确保sql是使用索引来访问纪录的，必要的时候，请使用explain 检查sql 的执行计划，判断是否按照预期使用了索引。
2. 由于mysql 的行锁是针对索引加的锁，不是针对纪录加的锁，所以虽然是访问不同行的纪录，但是如果是相同的索引键，是会被加锁的。应用设计的时候也要注意，这里和Oracle 有比较大的不同。
3. 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，当表有主键或者唯一索引的时候，不是必须使用主键或者唯一索引锁定纪录，其他普通索引同样可以用来检索纪录，并只锁定符合条件的行。
4. 用SHOW INNODB STATUS 来确定最后一个死锁的原因。查询的结果中，包括死锁的事务的详细信息，包括执行的SQL 语句的内容，每个线程已经获得了什么锁，在等待什么锁，以及最后是哪个线程被回滚。详细的分析死锁产生的原因，可以通过改进程序有效的避免死锁的产生。
5. 如果应用并不介意死锁的出现，那么可以在应用中对发现的死锁进行处理。
6. 确定更合理的事务大小，小事务更少地倾向于冲突。
7. 如果你正使用锁定读，（SELECT ... FOR UPDATE 或... LOCK IN SHARE MODE），试着用更低的隔离级别，比如READ COMMITTED。
8. 以固定的顺序访问你的表和行。则事务形成良好定义的查询并且没有死锁。
