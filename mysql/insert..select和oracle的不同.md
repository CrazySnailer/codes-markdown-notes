当使用insert...select...进行记录的插入时，如果select 的表是innodb 类型的，不论insert 的表是什么类型的表，都会对select 的表的纪录进行锁定。对于那些从oracle 迁移过来的应用，需要特别的注意，因为oracle 并不存在类似的问题，所以在oracle 的应用中insert...select...操作非常的常见。例如：有时候会对比较多的纪录进行统计分析，然后将统计的中间结果插入到另外一个表，这样的操作因为进行的非常少，所以可能并没有设置相应的索引。如果迁移到mysql数据库后不进行相应的调整，那么在进行这个操作期间，对需要select 的表实际上是进行的全表扫描导致的所有记录的锁定，将会对应用的其他操作造成非常严重的影响。

究其主要原因，是因为mysql 在实现复制的机制时和oracle 是不同的，如果不进行select 表的锁定，则可能造成从数据库在恢复期间插入结果集的不同，造成主从数据的不一致。如果不采用主从复制，关闭binlog 并不能避免对select 纪录的锁定，某些文档中提到可以通过设置innodb_locks_unsafe_for_binlog 来避免这个现象，当这个参数设置为true 的时候，将不会对select 的结果集加锁，但是这样的设置将可能带来非常严重的隐患。如果使用这个binlog 进行从数据库的恢复，或者进行主数据库的灾难恢复，都将可能和主数据库的执行效果不同。

因此，我们并不推荐通过设置这个参数来避免insert...select...导致的锁，如果需要进行可能会扫描大量数据的insert...select 操作，我们推荐使用select...into outfile 和load data infile 的组合来实现，这样是不会对纪录进行锁定的。
